<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Draw</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #282c34;
            color: #61dafb;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 1px solid #ffffff;
            cursor: crosshair;
            image-rendering: pixelated; /* Ensure pixelated rendering */
        }
        #controls {
            margin: 10px;
            display: flex;
            justify-content: space-between;
            width: 80%;
        }
        #brushSize, #colorPicker, #liveCount, #downloadBtn {
            margin: 0 10px;
        }
        #zoomLevel {
            margin-left: 20px;
        }
    </style>
</head>
<body>
    <h1>Live Draw</h1>
    <div id="controls">
        <label for="brushSize">Brush Size:</label>
        <select id="brushSize">
            <option value="1">1px</option>
            <option value="5">5px</option>
        </select>

        <label for="colorPicker">Color:</label>
        <input type="color" id="colorPicker" value="#000000">

        <button id="downloadBtn">Download Canvas</button>
        
        <div id="liveCount">0 Online</div>

        <label for="zoomLevel">Zoom Level:</label>
        <span id="zoomLevel">1.0x</span>
    </div>
    <canvas id="drawingCanvas"></canvas>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');

        // Initial setup
        const canvasSize = 500;
        canvas.width = canvasSize;
        canvas.height = canvasSize;

        let scale = 10;
        const updateCanvasScale = () => {
            canvas.style.transform = `scale(${scale})`;
            document.getElementById('zoomLevel').innerText = `${scale.toFixed(1)}x`;
        };
        updateCanvasScale();

        let drawing = false;
        let brushSize = parseInt(document.getElementById('brushSize').value);
        let color = document.getElementById('colorPicker').value;

        document.getElementById('brushSize').addEventListener('change', (e) => {
            brushSize = parseInt(e.target.value);
        });

        document.getElementById('colorPicker').addEventListener('change', (e) => {
            color = e.target.value;
        });

        window.addEventListener('wheel', (e) => {
            scale += e.deltaY > 0 ? -0.5 : 0.5;
            scale = Math.min(Math.max(2, scale), 20); // Limit zoom between 2x and 20x
            updateCanvasScale();
        });

        const startDrawing = (e) => {
            drawing = true;
            draw(e);
        };

        const stopDrawing = () => {
            drawing = false;
            ctx.beginPath();
        };

        const draw = (e) => {
            if (!drawing) return;
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / scale);
            const y = Math.floor((e.clientY - rect.top) / scale);
            ctx.lineWidth = brushSize;
            ctx.strokeStyle = color;
            ctx.lineCap = 'round';

            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x, y);

            socket.emit('draw', { x, y, color, size: brushSize });
        };

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mousemove', draw);

        socket.on('draw', (data) => {
            ctx.lineWidth = data.size;
            ctx.strokeStyle = data.color;
            ctx.lineCap = 'round';

            ctx.lineTo(data.x, data.y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(data.x, data.y);
        });

        // Load existing drawings
        socket.on('load', (drawingData) => {
            drawingData.forEach((data) => {
                ctx.lineWidth = data.size;
                ctx.strokeStyle = data.color;
                ctx.lineCap = 'round';

                ctx.lineTo(data.x, data.y);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(data.x, data.y);
            });
        });

        // Update live user count
        socket.on('liveCount', (count) => {
            document.getElementById('liveCount').innerText = `${count} Online`;
        });

        // Download canvas as image
        document.getElementById('downloadBtn').addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'canvas.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        });
    </script>
</body>
</html>
